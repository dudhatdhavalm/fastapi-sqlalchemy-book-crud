from datetime import date
from app.schemas.book import BookCreate

from app.crud.crud_book_plain import *
from app.crud.crud_book_plain import CRUDBook
from unittest.mock import MagicMock
from app.models.book import Book

import pytest
from bson import ObjectId
from pymongo.collection import Collection
from unittest.mock import MagicMock, patch
from app.crud.crud_book import CRUDBook


def test_create_sets_created_at():
    # We will use mocks to represent MongoClient and collections
    mock_client = MockMongoClient()
    mock_collection = MockCollection()
    mock_client.get_database.return_value.get_collection.return_value = mock_collection
    
    # Book data as you would send to a pymongo collection, without the id field since it is autogenerated.
    book_data = {
        "title": "Mock Book Title",
        "author": "Mock Author",
        "description": "Mock Description"
    }
    
    # Mock insertion to return the necessary data
    mock_collection.insert_one.return_value.inserted_id = "mocked_id"
    
    # Simulate the MongoDB document that would be returned
    book_document = book_data.copy()
    book_document["_id"] = "mocked_id"
    book_document["created_at"] = date.today()
    
    # Set the mock to return the document when find_one is called
    mock_collection.find_one.return_value = book_document
    
    # Create an instance of the rewritten CRUD class that is compatible with PyMongo
    crud_book = CRUDBookMongo()
    
    # Here we call the create method on the CRUDBookMongo instance,
    # passing our mocked book data and using the simulated db connection
    created_book = crud_book.create(db=mock_client, obj_in=book_data)
    
    # Assert that a book document has been "created" with the correct 'created_at' value
    assert created_book["created_at"] == date.today() 


def test_create_adds_book_to_session(mock_db_collection, book_data):
    # This is assuming mock_db_collection is an instance of MockCollection
    # that is mocking the actual pymongo collection method insert_one.
    crud_book = CRUDBook()
    crud_book.create(db=mock_db_collection, obj_in=book_data)
    mock_db_collection.insert_one.assert_called_once()


def test_create_commits_session(mock_db_collection, book_data):
    mock_db_collection.insert_one = MagicMock()
    crud_book = CRUDBook()
    crud_book.create(db=mock_db_collection, obj_in=book_data)
    mock_db_collection.insert_one.assert_called_once()


def test_create_refreshes_book_object(monkeypatch):
    book_data = book_data()  # Call the predefined function to get a book dictionary object
    
    # Initialize the mock collection and CRUD object
    mock_collection = MockCollection()
    crud_book = CRUDBookPlain(mock_collection)

    # Patch the find_one method of the mock collection to ensure it's called and behaves correctly
    refreshed_book_mock = MagicMock(return_value=book_data)
    monkeypatch.setattr(mock_collection, 'find_one', refreshed_book_mock)

    # Make the call to create a new book and check if find_one is called to refresh the book object
    result = crud_book.create(book_data)
    refreshed_book_mock.assert_called_once()

    # Further assertions may be added if needed, for example to check if the book data returned matches the input

# This part of the code should usually reside in a test configuration file.
@pytest.fixture
def monkeypatch():
    from _pytest.monkeypatch import MonkeyPatch
    mp = MonkeyPatch()
    try:
        yield mp
    finally:
        mp.undo()

# Depending on the test framework, you would likely need to mark this test coroutine:
# pytest.mark.asyncio
# async def test_create_sets_created_at():
# And then make corresponding async calls within the function.

# In addition, you would need to set up your test configuration to provide the appropriate fixtures for mocking MongoClient. The above code assumes a 'MockMongoClient' that returns a mocked database and collection.



@pytest.fixture
def mock_db_session():
    class MockSession:
        def add(self, obj):
            pass

        def commit(self):
            pass

        def refresh(self, obj):
            obj.id = 1  # Simulate the object being refreshed from the database

    return MockSession()



@pytest.fixture
def book_data():
    return BookCreate(title="Sample Book", pages=123, author_id=1)


def test_create_runs_without_errors(mock_db_session, book_data):
    crud_book = CRUDBook()
    book = crud_book.create(db=mock_db_session, obj_in=book_data)
    assert book is not None

@pytest.fixture
def mock_collection():
    return MockCollection()

@pytest.fixture
def mock_crud_book(mock_collection):
    return CRUDBook(mock_collection)

@pytest.fixture
def mock_book_id():
    return ObjectId()
